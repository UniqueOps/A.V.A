#!/bin/bash

################################################################################
# colorize() 
# v1.1.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description:
#
# Globals:
# * COLORIZE_RAW_URL
#
# Functions:
# * colorize()
# * palette()
# * _parse_color()
#
# Dependencies:
# * core.shl
################################################################################

################################################################################
################################### Globals ####################################
################################################################################

COLORIZE_RAW_URL="${TRITON_RAW_URL}/colorize/colorize.shl"

################################################################################
################################### Includes ###################################
################################################################################

if _core_test >/dev/null 2>&1; [ $? != 3 ]
then
  source /proc/self/fd/0 <<<"$(< <(curl -ks https://codesilo.dimenoc.com/grahaml/triton/raw/master/core/include_core_lib))"
fi

################################################################################
################################## Functions ###################################
################################################################################

#*******************************************************************************
# _colorize_test() 
# v1.0.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description:
# Used to test for the presence of colorize.shl in the current shell.
#
# Returns:
# Returns 3 indicating that the colorize.shl has been sourced into the current
# shell.
#
# Options:
# None.
#
# Arguments:
# None.
#
# Dependencies:
# None.
#*******************************************************************************

function _colorize_test()
{
  return 3
}

#*******************************************************************************
# colorize()
# v1.2.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description:
# Generates color and formatting escape sequences used to stylize text printed
# to STDOUT.
#
# Returns:
# Prints an escape sequence used to color and format text to STDOUT. The 
# sequence printed is determined by the command line options passed to it when 
# called. If no options are set, it will print the escape sequence to reset all 
# attributes.
#
# Options:
# -b, --bold
#   Sets the bold text format.
#
# -c COLOR, --color COLOR
#   Sets the text color to the COLOR argument.
#
# -g COLOR, --background COLOR
#   Sets the background color to the COLOR argument.
#
# -r, --reset
#   Resets all attributes.
#
# -u, --underline, --underlined
#   Sets the underline text format.
#
# The following are accepted as COLOR arguments for both the '-c' and 'g' 
# options*:
# * black
# * red
# * green
# * yellow
# * blue
# * magenta/purple
# * cyan
# * light gray/light grey
# * dark gray/dark grey, gray, grey
# * light red
# * light green
# * light yellow
# * light blue
# * light magenta/light purple
# * light cyan
# * white
#
# * Color names are NOT case, and white-space sensitive. E.g. "light red", 
# "LIGHT red", and "lightred" are treated the same.
#
# Arguments:
# None
#
# Dependencies:
# * core.shl::printerr()
# * core.shl::E_GETOPT
# * core.shl::E_OPTPARSE
#*******************************************************************************

function colorize()
{
  # Declare options string
  local options

  # Initialize options string and check for errors.
  if ! options=$(
    getopt -o b,c:,g:,r,u \
    -l bold,color:,background:,reset,underline,underlined -- "$@"
    )
  then
    printerr "$E_GETOPT"
    return 1
  fi

  eval set -- "$options"

  # Initialize flags
  local bflag='false'
  local cflag='false'
  local gflag='false'
  local rflag='false'
  local uflag='false'

  local color_arg
  local bg_arg

  while true
  do
    case "$1" in
      -b | --bold ) bflag='true' ;;
      -c | --color )
        cflag='true'
        color_arg="$2"
        shift
        ;;
      -g | --background )
        gflag='true'
        bg_arg="$2"
        shift
        ;;
      -u | --underline | --underlined ) uflag='true' ;;
      -r | --reset ) rflag='true' ;;
      -- )
        shift
        break
        ;;
      *)
        printerr "$E_OPTPARSE $1" 
        return 1
        ;;
    esac
    shift
  done

  # Code to return
  local code="\e["

  # Flag for multiple codes
  local multiple='false'

  # Formatting
  local reset=0
  local bold=1
  local underline=4

  # Set reset if rflag is set or no other flag is set.
  # The reset flag might seem redundant but it provides a method to "force"
  # text to be formatted a particular way without adding multiple variables.
  if $rflag || [[ ! $bflag && ! $cflag && ! $gflag && ! $uflag ]]
  then
    multiple='true'
    code="${code}$reset"
  fi

  if $bflag
  then
    if $multiple
    then
      code="${code};"
    else
      multiple='true'
    fi
    code="${code}$bold"
  fi

  if $uflag
  then
    if $multiple
    then
      code="${code};"
    else
      multiple='true'
    fi
    code="${code}$underline"
  fi

  if $cflag 
  then
    if $multiple
    then
      code="${code};"
    else
      multiple='true'
    fi
    
    color_arg="$(echo "$color_arg" \
               | tr -d '[:space:]' \
               | tr '[:upper:]' '[:lower:]')"

    local color="$(_parse_color "$color_arg")"
    code="${code}${color}"
  fi

  if $gflag 
  then
    if $multiple
    then
      code="${code};"
    else
      multiple='true'
    fi
    
    bg_arg="$(echo "$bg_arg" \
               | tr -d '[:space:]' \
               | tr '[:upper:]' '[:lower:]')"

    local background="$(_parse_color "$bg_arg" "true")"
    code="${code}${background}"
  fi

  code="${code}m"

  echo "$code"
}

#*******************************************************************************
# palette() 
# v1.0.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description:
# Prints foreground, and background color combinations along with normal, bold,
# and underlined text in a grid.
#
# Returns:
# Nothing.
#
# Options:
# None.
#
# Arguments:
# None.
#
# Dependencies:
# colorize()
#*******************************************************************************

function palette()
{
  local i
  local j
  local k

  local fg_c
  local fg_l
  local bg_c
  local bg_l
  local mode
  local rs=$(colorize)

  for ((i=0; i<17; i++))
  do
    if ((i==0))
    then
      for ((j=0; j<17; j++))
      do
        if ((j<9))
        then
          bg_l=4
        else
          bg_l=10
        fi
        (( bg_c = (j - 1) % 8 ))

        if ((j==0))
        then
          printf "%7s" ""
        else
          printf " %4s " "${bg_l}${bg_c}m"
        fi
      done
      echo ""
    else
      for ((k=0; k<3; k++))
      do
        case "$k" in
          0 )
            mode="0"
            ;;
          1 )
            mode="1"
            ;;
          2 )
            mode="4"
            ;;
        esac

        for ((j=0; j<17; j++))
        do
          if ((i<9))
          then
            fg_l=3
          else
            fg_l=9
          fi
          (( fg_c = (i - 1) % 8 ))

          if ((j<9))
          then
            bg_l=4
          else
            bg_l=10
          fi
          (( bg_c = (j - 1) % 8 ))

          if ((j==0))
          then
            if ((k==0))
            then
              printf " %5s " "${fg_l}${fg_c}m"
            else
              printf " %5s " "${mode};${fg_l}${fg_c}m"
            fi
          else
            printf "%b %4s %b" "\e[${mode};${fg_l}${fg_c};${bg_l}${bg_c}m" "rgb" "${rs}"
          fi
        done
        echo ""
      done
    fi
  done
}

#*******************************************************************************
# _parse_color() 
# v1.0.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description:
# Used to convert a color name string into the appropriate escape sequence.
#
# Returns:
# Outputs a two digit number to STDOUT. The first digit sets the "layer"
# modified (foreground/text, or background), and the value or "shade" of the 
# color (normal, or light). The second digit sets the hue.
#
# Options:
# None.
#
# Required Arguments:
# The first argument must be a string containing the color to be parsed.
#
# Optional Arguments:
# The second argument if set (having any value other than an empty string) 
# will switch the layer to the background. If the second argument is not set,
# the layer is assumed to be the foreground.
#
# Dependencies:
# core.shl::printerr()
#*******************************************************************************

function _parse_color()
{
  if [ -z $1 ]
  then
    printerr "Requires at least one argument."
    return 1
  fi

  local color="$1"

  # Formatting
  local reset=0
  local bold=1
  local underline=4

  # Hue
  local black=0
  local red=1
  local green=2
  local yellow=3
  local blue=4
  local magenta=5
  local cyan=6
  local gray=7

  # Layer (foreground or background)
  # Initialized as '3' which is the foreground
  local layer=3

  local offset_bg=1
  local offset_light=6

  if [ ! -z $2 ]
  then
    (( layer += offset_bg ))
  fi

  # Defaults
  local default_color=9

  # Return string
  local code

  case "$color" in
    "black" )
      code="${layer}${black}"
      ;;
    "red" )
      code="${layer}${red}"
      ;;
    "green" )
      code="${layer}${green}"
      ;;
    "yellow" )
      code="${layer}${yellow}"
      ;;
    "blue" )
      code="${layer}${blue}"
      ;;
    "magenta" | "purple" )
      code="${layer}${magenta}"
      ;;
    "cyan" )
      code="${layer}${cyan}"
      ;;
    "lightgray" | "lightgrey" )
      code="${layer}${gray}"
      ;;
    "darkgray" | "darkgrey" | "gray" | "grey" )
      (( layer += offset_light ))
      code="${layer}${black}"
      ;;
    "lightred" )
      (( layer += offset_light ))
      code="${layer}${red}"
      ;;
    "lightgreen" )
      (( layer += offset_light ))
      code="${layer}${green}"
      ;;
    "lightyellow" )
      (( layer += offset_light ))
      code="${layer}${yellow}"
      ;;
    "lightblue" )
      (( layer += offset_light ))
      code="${layer}${blue}"
      ;;
    "lightmagenta" | "lightpurple" )
      (( layer += offset_light ))
      code="${layer}${magenta}"
      ;;
    "lightcyan" )
      (( layer += offset_light ))
      code="${layer}${cyan}"
      ;;
    "white" )
      (( layer += offset_light ))
      code="${layer}${gray}"
      ;;
    * )
      # In the case of an unrecognized color, set the default color. It isn't
      # worth creating an error message for something that should be 
      # non-critical.
      code="${layer}9"
      ;;
  esac

  echo "$code"

  return 0
}