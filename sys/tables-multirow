#!/bin/bash

# Field headings
FIELDS=("Service" "Version" "Daemon" "Running" "Ports")

# Field Arrays

# Labels
labels[0]="${FIELDS[0]}"
labels_size=${#FIELDS[0]}

# Versions
versions[0]="${FIELDS[1]}"
versions_size=${#FIELDS[1]}

# Daemons
daemons[0]="${FIELDS[2]}"
daemons_size=${#FIELDS[2]}

# States
states[0]="${FIELDS[3]}"
states_size=${#FIELDS[3]}

STATE_UP="UP"
STATE_DOWN="DOWN"

# Ports
ports[0]="${FIELDS[4]}"
ports_size=${#FIELDS[4]}

# Services

# Functions

# Prints a table row.
function print_row() {
  # $1 = index
  
  # Spacer variables are necessary to properly align fields with color codes.
  
  # First, the color codes are stripped out and the remain characters counted.
  states_temp=$(echo -e "${states[$1]}" | sed 's/\x1B\[[0-9;]*[JKmsu]//g')
  
  # The spacer width is then difference between the normal column size and
  # the length of the field (without color codes).
  (( states_spacer = states_size - ${#states_temp} ))
    
  # The format for fields is %${field_size}s.
  # The format for a field with color codes is %${field_spacer}s%b.
  format=" %-${labels_size}s | %${versions_size}s | %${daemons_size}s | %${states_spacer}s%b | %${ports_size}s\n"

  # Any field with color codes must be preceded by an empty string ("") or 
  # the formatting will break.
  printf "$format" "${labels[$1]}" "${versions[$1]}" "${daemons[$1]}" "" "${states[$1]}" "${ports[$1]}"
    
  # Print the divider between the header, and the remaing rows.    
  if [ "$1" -eq 0 ]; then
    printf "%*s\n" "$width" | tr ' ' '=';
  fi
}

# Field Accessors

# Setters

# These functions update the parallel arrays, and manage the size variable
# for the respective field.

# "Set" here is a bit of a misnomer since they are really adding a new element
# to the end of a list instead of setting the value of an element.
# Using the convention "add_field" might be more appropriate here.

function set_labels() {
  labels=("${labels[@]}" "$1")
  
  if [ ${#1} -gt "$labels_size" ]; then
    labels_size=${#1}
  fi
}

function set_versions() {
  versions=("${versions[@]}" "$1")
  
  if [ ${#1} -gt "$versions_size" ]; then
    versions_size=${#1}
  fi
}

function set_daemons () {
  daemons=("${daemons[@]}" "$1")
  
  if [ ${#1} -gt "$daemons_size" ]; then
    daemons_size=${#1}
  fi
}

function set_states() {
  if [ ${#1} -gt "$states_size" ]; then
    states_size=${#1}
  fi
  
  if [ "$1" == "$STATE_DOWN" ]; then
    states=("${states[@]}" "$R1$1$RS")
  elif [ "$1" == "$STATE_UP" ]; then
    states=("${states[@]}" "$G1$1$RS")
  fi
}

function set_ports (){
  ports=("${ports[@]}" "$1")
  
  if [ ${#1} -gt "$ports_size" ]; then
    ports_size=${#1}
  fi
}

# "Constructor"

function new_service() {
  # $1 = label
  # $2 = version
  # $3 = daemon
  # $4 = state
  # $5 = ports
  
  set_labels "$1"
  set_versions "$2"
  set_daemons "$3"
  set_states "$4"
  set_ports "$5"
}

# Service Checks

# There are functions for categories of related processes.

# Categories with examples:
#  * Control panel - cPanel, Plesk
#  * DNS software - BIND, NSD
#  * Webserver - Apache, NGINX, Litespeed
#  * Database - MySQL, MariaDB, PostgreSQL
#  * Mail Transfer Agent - Exim, Postfix
#  * Mail server - Dovecot, Courier
#  * FTP server - Pure-FTPd, ProFTPD
#
# Note: Not all of the checks for the above services are fully implemented,
# and some are implemented but not enabled barring further testing.

# There are currently five fields for each process.
#  1. Service - service_label
#  The name associated with the service e.g. Apache. These value of these
#  are defined.
#
#  2. Version - service_v
#  The major, and minor numbers of the service's version number (minimum).
#
#  3. Daemon  - service_d
#  The name of the daemon process e.g. httpd.
#
#  4. Running - service_state
#  The state of process. UP if the process is running, DOWN if it is not. This 
#  does not mean that the process is functioning properly, only that it exists.
#  Processes are initially assumed to be down.
#
#  5. Ports   - service_ports
#  The ports the process is currently listening on. Keep in mind that these are 
#  not necessarily what the process is configured to listen on.
#

function check_control_panel() {
  # To-Do
  # * Add Plesk check
  #   * cPanel and Plesk should be mutually exclusive.
  # * Rename variables to be service agnostic
    
  # cPanel

  cpanel_label="cPanel"
  cpanel_v=$(cat /usr/local/cpanel/version 2>/dev/null)
  cpanel_d="cpsrvd"
  cpanel_state="$STATE_DOWN"
  cpanel_ports=$(get_ports $cpanel_d)

  if [[ $(pgrep "$cpanel_d") ]]; then
    cpanel_state="$STATE_UP"
  fi
  
  new_service "$cpanel_label" "$cpanel_v" "$cpanel_d" "$cpanel_state" "$cpanel_ports"
}

function check_webserver() {
  # To-Do
  # * Test NGINX check
  # * Test Litespeed check
  #   * Apache, NGINX and Litespeed are NOT mutually exclusive.
  
  # Apache / HTTPD

  apache_label="Apache"
  apache_v=$(httpd -v 2>/dev/null | awk 'FNR==1 {print $3}' | cut -d '/' -f 2)
  apache_d="httpd"
  apache_state="$STATE_DOWN"
  apache_ports=$(get_ports $apache_d)

  if [[ $(pgrep "$apache_d") ]]; then
    apache_state="$STATE_UP"
  fi

  new_service "$apache_label" "$apache_v" "$apache_d" "$apache_state" "$apache_ports"
  
  # Nginx
  # This probably works fine but needs more testing.
  
  if type nginx >/dev/null 2>&1 || type /usr/local/nginx/sbin/nginx >/dev/null 2>&1; then
    nginx_label="NGINX"
  
    if type nginx >/dev/null 2>&1; then
      # NginxCP
      nginx_v=$(nginx -v 2>&1 | cut -d '/' -f 2)
      nginx_label="NginxCP"
    elif type /usr/local/nginx/sbin/nginx >/dev/null 2>&1; then
      # Version check for Cpnginx
      nginx_v=$(/usr/local/nginx/sbin/nginx -v 2>&1 | cut -d '/' -f 2)
      nginx_label="Cpnginx"
    fi
  
    nginx_d="nginx"
    nginx_state="$STATE_DOWN"
    nginx_ports=$(get_ports $nginx_d)
  
    if [[ $(pgrep "$nginx_d") ]]; then
      nginx_state="$STATE_UP"
    fi
    
    new_service "$nginx_label" "$nginx_v" "$nginx_d" "$nginx_state" "$nginx_ports"
  fi
}

function services_main() {
  # Call Service Checks
  #
  # These are in their own functions for mostly organizational purposes but it
  # also allows the order the services are listed in to be easily changed.

  check_control_panel
  check_webserver
  
  # Title
  TITLE="Services Check"
  title_size=${#TITLE}

  # Formatting
  width=$(( 
      2 \
      + ( 3 * ( ${#FIELDS[@]} - 1 ) ) \
      + labels_size \
      + versions_size \
      + daemons_size \
      + states_size \
      + ports_size ))

  # Find the number of '=' needed on either side of the title
  # divide the difference of the width and the title size + 2 (for spaces) by two 
  title_divider=$(( ( width - ( title_size + 2 ) ) / 2 )) 
  title_divider_2=$title_divider

  # If the parity of $width and $title_size are not the same then an extra '=' 
  # is needed to center the title.
  if [ $(( width % 2 )) -ne $(( title_size % 2 )) ]; then
    ((title_divider_2++))
  fi

  # Print the table
  printf "$SC%*s$W1" $title_divider | tr ' ' '=';
  printf " %s " "$TITLE"
  printf "$SC%*s$RS\n" $title_divider_2 | tr ' ' '='

  # Print Rows
  for ((i=0; i<${#labels[*]}; i++)); do
    print_row $i
  done
}

services_main