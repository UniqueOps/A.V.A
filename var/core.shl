#!/bin/bash

################################################################################
# core.shl
# v1.6.1
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description: A collection of functions intended to make writing new scripts, 
# or updating existing scripts easier.
#
# Functions:
# * printerr()
# * bytes_to_hr()
# * hr_to_bytes()
# * human_readable()
#
# Dependencies:
# None.
################################################################################

################################################################################
################################## Functions ###################################
################################################################################

#*******************************************************************************
# printerr()
# v1.0.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description: Redirects error messages to STDERR, and uses the FUNCNAME 
# environment variable  to automatically create more descriptive error messages.
#
# Returns: Prints the name of the calling function followed by an error message, 
# and the function call stack to STDERR.
#
# Options:
# -f FILENAME 
#   Adds a filename to the output of the error message.
#
# -l LINE_NUMBER
#   Adds a line number to the output of the error message.
#
# -r REPOSITORY_URL
#   Adds "Please report any issues here: REPOSITORY_URL" to the output of the
#   error message.
#
# -w 
#   Makes output less verbose. The function will not print the call stack when
#   this option is set.
#
# Arguments: An argument containing an error message should be passed. This 
# isn't technically required; the function will still output information with no
# arguments. There is no way to enforce a required argument without having this
# function generate its own error message (which may obfuscate an error in the
# calling function).
#
# Dependencies:
# None.
#
# Notes: The Bash built-in 'caller' can be used to implement a similar function 
# that includes line numbers but can only be used with regular files.
#*******************************************************************************

function printerr()
{
  local options
  if ! options=$(getopt -o f:,l:,r:,w -- "$@")
  then
    printerr -f "$CORE_FILENAME" -l "177" -r "$CORE_BLOB_URL" "$E_GETOPT"
    return 1
  fi

  eval set -- "$options"

  local file_name=""
  local line_num=""
  local repo_url=""
  local wflag='false'

  while true
  do
    case "$1" in
      -f )
        file_name="$2"
        shift
        ;;
      -l )
        line_num="$2"
        shift
        ;;
      -r )
        repo_url="$2"
        shift
        ;;
      -w )
        wflag='true'
        ;;
      -- )
        shift
        break
        ;;
      * )
        printerr -f "$CORE_FILENAME" -l "207" -r "$CORE_BLOB_URL" "$E_OPTPARSE $1"
        return 1
        ;;
    esac
    shift
  done

  local message="$1"

  # FUNCNAME is an array that contains the call stack.
  # The index '0' is the current function, 1 is the previous function, and so
  # on. The last element in the array should contain 'main' if called within a
  # script.
  printf "Error in %s" "${FUNCNAME[1]}" >&2

  if is_not_empty "$file_name" && is_not_empty "$line_num"
  then
    printf " (%s:%s)" "$file_name" "$line_num" >&2
  elif is_not_empty "$file_name"
  then
    printf " (file %s)" "$file_name" >&2
  elif is_not_empty "$line_num"
  then
    printf " (line %s)" "$line_num" >&2
  fi

  printf ": %s\n" "$message" >&2

  if ! $wflag
  then
    printf "\nCall stack (most recent call first):\n" >&2 # Print the call stack.

    for (( i = 1; i < ${#FUNCNAME[@]}; i++ )) # Prints the index and name of each function in the call stack.
    do
      printf "\t%s()\n" "${FUNCNAME[$i]}" >&2
    done
  fi

  if is_not_empty "$repo_url"
  then
    printf "\nPlease report any issues here: ${repo_url}\n" >&2
  fi

  return 0
}

#*******************************************************************************
# bytes_to_hr() 
# v1.1.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description: Converts bytes to a human readable file size.
#
# Returns: An integer representing the number of byte multiples followed 
# immediately by a single character representing the unit. If the input is not 
# a number, it returns "0B".
#
# Arguments: An integer representing bytes. Real numbers can be used but will be 
# rounded down to the nearest int.
#
# Dependencies:
# * is_empty()
#
# Known Issues: Arguments greater than or equal to 1024 YiB will cause an issue 
# but that should never occur under normal circumstances.
#*******************************************************************************

function bytes_to_hr()
{
  local size
  local units="BKMGTPEZY"

  size="$(grep -m1 -oE "[[:digit:]]+" <<<"$1" | head -1)"

  if is_empty "$size" || (( size == 0 ))
  then
    echo "0B"
    return 0
  fi

  awk '{ 
    base = int(log($1) / log(1024))
    factor = 1024 ^ base
    size = $1 / factor
    unit = substr($2,base+1,1)
    printf("%0.2f%s\n",size,unit)
  }' <<<"$size $units"

  return 0
}

#*******************************************************************************
# hr_to_bytes() 
# v1.0.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description: Converts a human readable file size to bytes.
#
# Returns: Outputs an integer representing the number of bytes. 
#
# Arguments: A file size; an integer or real number immediately followed by a
# character representing a unit. Accepted unit characters are B, K, M, G, T, P, 
# E, Z, and Y. Input is treated as bytes when no unit is provided.
#
# Dependencies:
# * printerr()
#*******************************************************************************

function hr_to_bytes()
{
  local size
  local unit
  local base
  local units="BKMGTPEZY"
  local pattern="(([[:digit:]]+)(\.[[:digit:]]+)?)(B|K|M|G|T|P|E|Z|Y)?"

  if is_empty "$1"
  then
    return 1
  fi

  if [[ $1 =~ $pattern ]]
  then
    size=${BASH_REMATCH[1]}
    unit=${BASH_REMATCH[4]}
  else
    printerr -w -f "$CORE_FILENAME" -r "$CORE_BLOB_URL" "'$1' is not a parseable file size." 
    return 1
  fi

  if [ "$unit" == 'B' ] || is_empty "$unit"
  then
    echo "${BASH_REMATCH[2]}"
    return 0
  fi

  base="${units%%$unit*}"
  base="${#base}"

  awk '{printf("%d\n",($1 * (1024 ^ $2)))}' <<<"$size $base"

  return
}

#*******************************************************************************
# human_readable() 
# v1.0.0
#
# Contributors:
# * Graham L. - Level 2 Support Technician - graham.l@hostdime.com
#
# Description: Converts a file size to the expected human readable form. 
# Wrapper for hr_to_bytes() into bytes_to_hr().
#
# Returns: An integer representing the number of byte multiples followed 
# immediately by a single character representing the unit. If the input is not 
# a number, it returns "0B".
#
# Arguments: A file size; an integer or real number immediately followed by a
# character representing a unit. Accepted unit characters are B, K, M, G, T, P, 
# E, Z, and Y. Input is treated as bytes when no unit is provided.
#
# Dependencies:
# * bytes_to_hr()
# * hr_to_bytes()
#*******************************************************************************

function human_readable()
{
  local bytes
  bytes=$(hr_to_bytes "$1")
  bytes_to_hr "$bytes"
  return
}

# Creates aliases for commonly used builtins and commands to avoid unexpected
# behavior when using them.
unalias builtin 2>/dev/null
unset -f builtin 2>/dev/null

alias cd="builtin cd" 2>/dev/null
alias command="builtin command" 2>/dev/null
alias source="builtin source" 2>/dev/null

alias grep="command grep" 2>/dev/null
alias ls="command ls" 2>/dev/null
alias mkdir="command mkdir" 2>/dev/null
alias rm="command rm" 2>/dev/null

# Function aliases for convenience and compatibility reasons.
alias hr="human_readable"
alias error_die="printerr"
alias error_warning="printerr -w"